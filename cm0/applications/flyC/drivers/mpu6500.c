#include <math.h>
#include <stdbool.h>
#include "board.h"
#include "drv_i2c.h"
#include "mpu6500.h"

#define MPUREG_WHOAMI_MPU9255                    0x68
#define BIT_PWR_MGMT_1_CLK_ZGYRO                 0x03            // PLL with Z axis gyroscope reference

#define MPUREG_SMPLRT_1000HZ                     0x00
#define MPUREG_SMPLRT_500HZ                      0x01
#define MPUREG_SMPLRT_250HZ                      0x03
#define MPUREG_SMPLRT_200HZ                      0x04
#define MPUREG_SMPLRT_100HZ                      0x09
#define MPUREG_SMPLRT_50HZ                       0x13

// bit definitions for MPUREG_GYRO_CONFIG
#define BITS_GYRO_FS_250DPS                      0x00
#define BITS_GYRO_FS_500DPS                      0x08
#define BITS_GYRO_FS_1000DPS                     0x10
#define BITS_GYRO_FS_2000DPS                     0x18
#define BITS_GYRO_FS_MASK                        0x18    // only bits 3 and 4 are used for gyro full scale so use this to mask off other bits

// Configuration bits MPU 3000, MPU 6000 and MPU9250
#define BITS_DLPF_CFG_256HZ_NOLPF2               0x00
#define BITS_DLPF_CFG_188HZ                      0x01
#define BITS_DLPF_CFG_98HZ                       0x02
#define BITS_DLPF_CFG_42HZ                       0x03
#define BITS_DLPF_CFG_20HZ                       0x04
#define BITS_DLPF_CFG_10HZ                       0x05
#define BITS_DLPF_CFG_5HZ                        0x06
#define BITS_DLPF_CFG_2100HZ_NOLPF               0x07
#define BITS_DLPF_CFG_MASK                       0x07

// bit definitions for MPUREG_INT_ENABLE
#define BIT_RAW_RDY_EN                           0x01
#define BIT_DMP_INT_EN                           0x02    // enabling this bit (DMP_INT_EN) also enables RAW_RDY_EN it seems
#define BIT_UNKNOWN_INT_EN                       0x04
#define BIT_I2C_MST_INT_EN                       0x08
#define BIT_FIFO_OFLOW_EN                        0x10
#define BIT_ZMOT_EN                              0x20
#define BIT_MOT_EN                               0x40
#define BIT_FF_EN                                0x80


static uint8_t buffer[14];
static bool isInit;

static void mpu6500_read_reg(uint8_t addr, uint8_t *data)
{
  i2c_read(MPU6500_DEFAULT_ADDRESS, addr, data, 1);
}

static void mpu6500_write_reg(uint8_t addr, uint8_t data )
{
  i2c_write_byte(MPU6500_DEFAULT_ADDRESS, addr, data);
}

static void mpu6500_read_regs(uint8_t addr, uint8_t *data, uint8_t len)
{
  i2c_read(MPU6500_DEFAULT_ADDRESS, addr, data, len);
}


/** Default constructor, uses default I2C address.
 * @see MPU6500_DEFAULT_ADDRESS
 */
void mpu6500_init(void)
{
  if (isInit)
    return;
   printf("mpu6500 init!\r\n");
   if(mpu6500_get_id() != MPUREG_WHOAMI_MPU9255)
   	{
    printf("read mpu6500 id error\r\n");
   }else
   	{
    printf("mpu6500 id 0x68\r\n");
   }
  // reset
  mpu6500_write_reg(MPU6500_RA_PWR_MGMT_1, (0x01<<MPU6500_PWR1_DEVICE_RESET_BIT));
  delay_ms(100);
  
  // wake up w/ Z axis clock reg
  mpu6500_write_reg(MPU6500_RA_PWR_MGMT_1, BIT_PWR_MGMT_1_CLK_ZGYRO);
  
  delay_ms(1);
  
  // GYO scale
  mpu6500_write_reg(MPU6500_RA_GYRO_CONFIG, BITS_GYRO_FS_2000DPS);
  
  delay_ms(1);

  // ACC scale
  mpu6500_write_reg(MPU6500_RA_ACCEL_CONFIG, 0x18);

  delay_ms(1);

  // Sample rate
  mpu6500_write_reg(MPU6500_RA_SMPLRT_DIV, MPUREG_SMPLRT_1000HZ);

  delay_ms(1);
  
  // LPF
  mpu6500_write_reg(MPU6500_RA_CONFIG, BITS_DLPF_CFG_98HZ);

  delay_ms(1);
  
  mpu6500_write_reg(MPU6500_RA_ACCEL_CONFIG_2,MPU6500_ACCEL_DLPF_BW_41);
  
  delay_ms(1);
  
  // Interrupt setup
  mpu6500_write_reg(MPU6500_RA_INT_PIN_CFG, 0x01<<4);
  mpu6500_write_reg(MPU6500_RA_INT_ENABLE, BIT_RAW_RDY_EN);
	
  isInit = true;
}

bool mpu6500_test(void)
{
  bool testStatus;

  if (!isInit)
    return false;

  testStatus = mpu6500_test_connection();

  return testStatus;
}

/** Verify the I2C connection.
 * Make sure the device is connected and responds as expected.
 * @return True if connection is valid, false otherwise
 */
bool mpu6500_test_connection(void)
{
  return mpu6500_get_id() == MPUREG_WHOAMI_MPU9255; //0x38 is MPU9250 ID with AD0 = 0;
}


// SMPLRT_DIV register

/** Get gyroscope output rate divider.
 * The sensor register output, FIFO output, DMP sampling, Motion detection, Zero
 * Motion detection, and Free Fall detection are all based on the Sample Rate.
 * The Sample Rate is generated by dividing the gyroscope output rate by
 * SMPLRT_DIV:
 *
 * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
 *
 * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or
 * 7), and 1kHz when the DLPF is enabled (see Register 26).
 *
 * Note: The accelerometer output rate is 1kHz. This means that for a Sample
 * Rate greater than 1kHz, the same accelerometer sample may be output to the
 * FIFO, DMP, and sensor registers more than once.
 *
 * For a diagram of the gyroscope and accelerometer signal paths, see Section 8
 * of the MPU-6000/MPU-6500 Product Specification document.
 *
 * @return Current sample rate
 * @see MPU6500_RA_SMPLRT_DIV
 */
uint8_t mpu6500_get_rate()
{

  i2c_read(MPU6500_DEFAULT_ADDRESS, MPU6500_RA_SMPLRT_DIV, buffer, 1);
  	
  return buffer[0];
}
/** Set gyroscope sample rate divider.
 * @param rate New sample rate divider
 * @see getRate()
 * @see MPU6500_RA_SMPLRT_DIV
 */
void mpu6500_set_rate(uint8_t rate)
{
  i2c_write_byte(MPU6500_DEFAULT_ADDRESS, MPU6500_RA_SMPLRT_DIV, rate);
}



// WHO_AM_I register

/** Get Device ID.
 * This register is used to verify the identity of the device (0b110100).
 * @return Device ID (should be 0x68, 104 dec, 150 oct)
 * @see MPU6500_RA_WHO_AM_I
 * @see MPU6500_WHO_AM_I_BIT
 * @see MPU6500_WHO_AM_I_LENGTH
 */
uint8_t mpu6500_get_id()
{

  i2c_read(MPU6500_DEFAULT_ADDRESS,MPU6500_RA_WHO_AM_I, buffer, 1);
  
  return buffer[0];
}

